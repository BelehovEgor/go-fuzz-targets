package main

// Edit if desired. Code generated by "fzgen -fillUnexported io".

import (
	io "io"
	"reflect"
	"testing"

	"github.com/BelehovEgor/fzgen/fuzzer"
)

// Example description
// Maybe only two type of realization
// No expected errors/panics
// No usage

// Generated
// Fuzzing successful 21
func Fuzz_N24_NopCloser_default(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors, fuzzer.FillUnexported)
		err := fz.Fill2(&r)
		if err != nil {
			return
		}

		// Put here your precondition of func arguments...

		io.NopCloser(r)

		// Put here your postcondition of func results...
	})
}

// Prompt
/*

You write fuzzing test using golang

Purpose: extend target func result check in fuzzing target

Requirements:
        + return only fuzz target code
        + you can past code only instead comments like "Put here your"
        + no explanation
        + process all edge cases
        + if arguments is invalid, target function shouldn't be call, this case should be skipped
        + if there is an explicit exception creation, skip only them by their message, the rest should cause a fuzzing test error
        + situations that should not occur during the execution of the function should end with t.Error
        + use simple strings for t.Error or t.Log without any variables format
        + don't use not exported fields in validation checks (its starts with lowercase letter)

Target func from package google.golang.org/api/youtube/v3:

func NopCloser(r Reader) ReadCloser {
        if _, ok := r.(WriterTo); ok {
                return nopCloserWriterTo{r}
        }
        return nopCloser{r}
}

Current fuzzing target test:

func Fuzz_N24_NopCloser(f *testing.F) {
        f.Fuzz(func(t *testing.T, data []byte) {
                var r io.Reader
                fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors, fuzzer.FillUnexported)
                err := fz.Fill2(&r)
                if err != nil {
                        return
                }

                // Put here your precondition of func arguments...

                io.NopCloser(r)

                // Put here your postcondition of func results...
        })
}

Current import aliases:

import (
        io "io"
        "reflect"
        "testing"

        "github.com/BelehovEgor/fzgen/fuzzer"
)

*/

// #LLM claude-3-7-sonnet-20250219
// count fixes: 2
// invalid reflection logic
// #summary:
// valid precondition.
// valid post condition. Logic error
// fuzzing fail before fixes

func Fuzz_N24_NopCloser_claude(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors, fuzzer.FillUnexported)
		err := fz.Fill2(&r)
		if err != nil {
			return
		}

		if r == nil {
			return
		}

		result := io.NopCloser(r)

		if result == nil {
			t.Error("NopCloser returned nil")
		}

		// Check that the returned ReadCloser contains the original reader
		// panic: reflect: call of reflect.Value.Elem on struct Value [recovered]
		// resultValue := reflect.ValueOf(result).Elem().FieldByName("Reader")
		resultValue := reflect.ValueOf(result).FieldByName("Reader")
		if !resultValue.IsValid() {
			t.Error("Unable to access Reader field in the result")
			return
		}

		// overkill logic
		//originalReader := reflect.ValueOf(r).Pointer()

		// panic: reflect: call of reflect.Value.Pointer on interface Value
		//resultReader := resultValue.Pointer()

		// if originalReader != resultReader {
		// 	t.Error("NopCloser does not wrap the original reader")
		// }

		// Test the Close method doesn't return error
		err = result.Close()
		if err != nil {
			t.Error("Close method returned an error")
		}
	})
}

// #LLM chatgpt-4o-latest-20250129
// count fixes: 3
// loose code - return only body of target without signature
// used unexported fields
// invalid using reflection
// #summary:
// valid precondition.
// invalid post condition.
func Fuzz_N24_NopCloser_gpt(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors, fuzzer.FillUnexported)
		err := fz.Fill2(&r)
		if err != nil {
			return
		}
		// Precondition of func arguments...
		if r == nil {
			return
		}

		// Call the target function
		res := io.NopCloser(r)

		// Postcondition of func results...
		if res == nil {
			t.Error("result is nil")
		}

		// reflect: call of reflect.Value.IsNil on struct Value
		//if reflect.ValueOf(res).IsNil() {
		if res == nil {
			t.Error("result is nil interface")
		}

		// if _, ok := r.(io.WriterTo); ok {
		// 	if _, ok := res.(nopCloserWriterTo); !ok {
		// 		t.Error("expected nopCloserWriterTo type")
		// 	}
		// } else {
		// 	if _, ok := res.(nopCloser); !ok {
		// 		t.Error("expected nopCloser type")
		// 	}
		// }
	})
}

func fabric_interface_io_Writer_PipeWriter(impl *io.PipeWriter) io.Writer {
	return impl
}

func fabric_interface_io_Writer_OffsetWriter(impl *io.OffsetWriter) io.Writer {
	return impl
}

func fabric_interface_io_WriterAt_OffsetWriter(impl *io.OffsetWriter) io.WriterAt {
	return impl
}

func fabric_interface_io_Reader_SectionReader(impl *io.SectionReader) io.Reader {
	return impl
}

func fabric_interface_io_Reader_PipeReader(impl *io.PipeReader) io.Reader {
	return impl
}

func fabric_interface_io_Reader_LimitedReader(impl *io.LimitedReader) io.Reader {
	return impl
}

func fabric_interface_io_ReaderAt_SectionReader(impl *io.SectionReader) io.ReaderAt {
	return impl
}

var FabricFuncsForCustomTypes map[string][]reflect.Value

func TestMain(m *testing.M) {
	FabricFuncsForCustomTypes = make(map[string][]reflect.Value)
	FabricFuncsForCustomTypes["io.ReaderAt"] = append(FabricFuncsForCustomTypes["io.ReaderAt"], reflect.ValueOf(fabric_interface_io_ReaderAt_SectionReader))
	FabricFuncsForCustomTypes["io.Writer"] = append(FabricFuncsForCustomTypes["io.Writer"], reflect.ValueOf(fabric_interface_io_Writer_PipeWriter))
	FabricFuncsForCustomTypes["io.Writer"] = append(FabricFuncsForCustomTypes["io.Writer"], reflect.ValueOf(fabric_interface_io_Writer_OffsetWriter))
	FabricFuncsForCustomTypes["io.Reader"] = append(FabricFuncsForCustomTypes["io.Reader"], reflect.ValueOf(fabric_interface_io_Reader_SectionReader))
	FabricFuncsForCustomTypes["io.Reader"] = append(FabricFuncsForCustomTypes["io.Reader"], reflect.ValueOf(fabric_interface_io_Reader_PipeReader))
	FabricFuncsForCustomTypes["io.Reader"] = append(FabricFuncsForCustomTypes["io.Reader"], reflect.ValueOf(fabric_interface_io_Reader_LimitedReader))
	FabricFuncsForCustomTypes["io.WriterAt"] = append(FabricFuncsForCustomTypes["io.WriterAt"], reflect.ValueOf(fabric_interface_io_WriterAt_OffsetWriter))
	FabricFuncsForCustomTypes["io.Reader"] = append(FabricFuncsForCustomTypes["io.Reader"], reflect.ValueOf(io.TeeReader))
	FabricFuncsForCustomTypes["io.ReadCloser"] = append(FabricFuncsForCustomTypes["io.ReadCloser"], reflect.ValueOf(io.NopCloser))
	FabricFuncsForCustomTypes["io.SectionReader"] = append(FabricFuncsForCustomTypes["io.SectionReader"], reflect.ValueOf(io.NewSectionReader))
	FabricFuncsForCustomTypes["io.Writer"] = append(FabricFuncsForCustomTypes["io.Writer"], reflect.ValueOf(io.MultiWriter))
	FabricFuncsForCustomTypes["io.Reader"] = append(FabricFuncsForCustomTypes["io.Reader"], reflect.ValueOf(io.MultiReader))
	FabricFuncsForCustomTypes["io.Reader"] = append(FabricFuncsForCustomTypes["io.Reader"], reflect.ValueOf(io.LimitReader))
	m.Run()
}
