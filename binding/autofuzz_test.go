package main

// Edit if desired. Code generated by "fzgen github.com/mholt/binding".

import (
	"reflect"
	"testing"

	"github.com/BelehovEgor/fzgen/fuzzer"
	binding "github.com/mholt/binding"
)

// No mocks
// Complex usage
//

// fuzzing successful 33
func Fuzz_N2_Errors_Has_default(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e *binding.Errors
		var class string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e, &class)
		if err != nil || e == nil {
			return
		}

		// Put here your precondition of func arguments...

		e.Has(class)

		// Put here your postcondition of func results...
	})
}

// Prompt
/*
You write fuzzing test using golang

Purpose: extend target func result check in fuzzing target

Requirements:
        + return only fuzz target code
        + you can past code only instead comments like "Put here your"
        + no explanation
        + process all edge cases
        + if arguments is invalid, target function shouldn't be call, this case should be skipped
        + if there is an explicit exception creation, skip only them by their message, the rest should cause a fuzzing test error
        + situations that should not occur during the execution of the function should end with t.Error
        + use simple strings for t.Error or t.Log without any variables format
        + don't use not exported fields in validation checks (its starts with lowercase letter)

Target func from package github.com/mholt/binding:

func (e *Errors) Has(class string) bool {
        for _, err := range *e {
                if err.Kind() == class {
                        return true
                }
        }
        return false
}


Example of using func:

func (e Errors) Handle(response http.ResponseWriter) bool {
        if e.Len() > 0 {
                response.Header().Set("Content-Type", jsonContentType)
                if e.Has(ContentTypeError) {
                        response.WriteHeader(http.StatusUnsupportedMediaType)
                } else {
                        response.WriteHeader(http.StatusBadRequest)
                }
                errOutput, _ := json.Marshal(e)
                response.Write(errOutput)
                return true
        }
        return false
}

Current fuzzing target test:

func Fuzz_N2_Errors_Has(f *testing.F) {
        f.Fuzz(func(t *testing.T, data []byte) {
                var e *binding.Errors
                var class string
                fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
                err := fz.Fill2(&e, &class)
                if err != nil || e == nil {
                        return
                }

                // Put here your precondition of func arguments...

                e.Has(class)

                // Put here your postcondition of func results...
        })
}

Current import aliases:

import (
        "reflect"
        "testing"

        "github.com/BelehovEgor/fzgen/fuzzer"
        binding "github.com/mholt/binding"
)
*/

// #LLM claude-3-7-sonnet-20250219
// count fixes: 0
// #summary:
// valid precondition.
// valid post condition.
// fuzzing 32
func Fuzz_N2_Errors_Has_claude(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e *binding.Errors
		var class string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e, &class)
		if err != nil || e == nil {
			return
		}

		// Store original errors for later comparison
		originalErrors := make([]binding.Error, len(*e))
		copy(originalErrors, *e)

		result := e.Has(class)

		// Verify result matches expected behavior
		hasMatchingError := false
		for _, err := range originalErrors {
			if err.Kind() == class {
				hasMatchingError = true
				break
			}
		}

		if result != hasMatchingError {
			t.Error("Has method returned incorrect result")
		}

		// Verify the function didn't modify the errors slice
		if len(*e) != len(originalErrors) {
			t.Error("Function modified the errors slice length")
		}

		for i := range originalErrors {
			if i >= len(*e) || !reflect.DeepEqual((*e)[i], originalErrors[i]) {
				t.Error("Function modified the errors slice content")
				break
			}
		}
	})
}

// #LLM chatgpt-4o-latest-20250129
// count fixes: 0
// #summary:
// valid precondition.
// invalid post condition.
// fuzz fail
func Fuzz_N2_Errors_Has_gpt(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e *binding.Errors
		var class string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e, &class)
		if err != nil || e == nil || class == "" {
			return
		}

		result := e.Has(class)

		// fail is here one of error should match but check tries for all error
		for _, err := range *e {
			if err.Kind() == class && !result {
				t.Error("expected true but got false")
			}
			if err.Kind() != class && result {
				t.Error("expected false but got true")
			}
		}
	})
}

var FabricFuncsForCustomTypes map[string][]reflect.Value

func TestMain(m *testing.M) {
	FabricFuncsForCustomTypes = make(map[string][]reflect.Value)
	m.Run()
}
