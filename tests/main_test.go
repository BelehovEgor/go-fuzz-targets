package tests

import (
	fuzz "github.com/AdaLogics/go-fuzz-headers"
	funcs "github.com/BelehovEgor/go-fuzz-targets/examples"
	"slices"
	"testing"
)

// simple types
func FuzzCalculateTotal(f *testing.F) {
	testCases := [][]interface{}{
		{10.0, 5, 0.08},
		{20.5, 3, 0.1},
		{0.0, 10, 0.05},
		{100.0, 0, 0.2},
		{1.0, -1, 0.0}, // Negative quantity to test error handling
		{1.0, 1, -0.1}, // Negative tax rate to test error handling
	}

	for _, tc := range testCases {
		f.Add(tc...)
	}

	f.Fuzz(func(t *testing.T, price float64, quantity int, taxRate float64) {
		total, err := funcs.CalculateTotal(price, quantity, taxRate)

		if price < 0 && err == nil {
			t.Errorf("expected error for negative quantity, but got none")
		}
		if quantity < 0 && err == nil {
			t.Errorf("expected error for negative quantity, but got none")
		}
		if taxRate < 0 && err == nil {
			t.Errorf("expected error for negative taxRate, but got none")
		}

		if err == nil && total < 0 {
			t.Errorf("total should not be negative, but got %f", total)
		}
	})
}

// use go-fuzz-headers for generate from bytes  structures
func FuzzCalculateTotalForProduct(f *testing.F) {
	f.Fuzz(func(t *testing.T, genData []byte) {
		cons := fuzz.NewConsumer(genData)
		product := funcs.Product{}
		err := cons.GenerateStruct(&product)

		t.Log(product)

		total, err := funcs.CalculateTotalForProduct(product)

		if product.Price < 0 && err == nil {
			t.Errorf("expected error for negative quantity, but got none")
		}
		if product.Quantity < 0 && err == nil {
			t.Errorf("expected error for negative quantity, but got none")
		}
		if product.TaxRate < 0 && err == nil {
			t.Errorf("expected error for negative taxRate, but got none")
		}

		if err == nil && total < 0 {
			t.Errorf("total should not be negative, but got %f", total)
		}
	})
}

// separate struct to types with go fuzz can create and create structs using them
func FuzzCalculateTotalForProduct2(f *testing.F) {
	// Define some sample inputs for fuzzing
	testCases := [][]interface{}{
		{"Laptop", 1000.0, 2, 0.08},
		{"Phone", 500.0, 3, 0.1},
		{"Tablet", 300.0, 0, 0.05},
		{"Monitor", 200.0, -1, 0.0}, // Negative quantity to test error handling
		{"Keyboard", 50.0, 1, -0.1}, // Negative tax rate to test error handling
	}

	for _, tc := range testCases {
		f.Add(tc...)
	}

	f.Fuzz(func(t *testing.T, name string, price float64, quantity int, taxRate float64) {
		product := funcs.Product{
			Name:     name,
			Price:    price,
			Quantity: quantity,
			TaxRate:  taxRate,
		}

		t.Log(product)

		total, err := funcs.CalculateTotalForProduct(product)

		if product.Price < 0 && err == nil {
			t.Errorf("expected error for negative quantity, but got none")
		}
		if product.Quantity < 0 && err == nil {
			t.Errorf("expected error for negative quantity, but got none")
		}
		if product.TaxRate < 0 && err == nil {
			t.Errorf("expected error for negative taxRate, but got none")
		}

		// Additional checks can be added here if needed
		if err == nil && total < 0 {
			t.Errorf("total should not be negative, but got %f", total)
		}
	})
}

// doesn't work cause cannot work with interfaces - generated by mistral
func FuzzGenerateJSON(f *testing.F) {
	testCases := [][]interface{}{
		{"name", "Alice", "age", 25, "isStudent", true},
		{"name", "Bob", "age", 30, "isStudent", false},
		{"name", "Charlie", "age", 22}, // Odd number of arguments to test error handling
		{"name", 123, "age", 25},       // Invalid key type to test error handling
	}

	for _, tc := range testCases {
		f.Add(tc...)
	}

	f.Fuzz(func(t *testing.T, args ...interface{}) {
		_, err := funcs.GenerateJSON(args...)
		if err != nil {
			// If there's an error, it's expected for invalid inputs
			return
		}
		// Additional checks can be added here if needed
	})
}

func FuzzGenerateJSON2(f *testing.F) {
	expectedErrors := []string{
		"key is not a string",
		"odd number of arguments",
	}

	f.Fuzz(func(t *testing.T, bytes []byte) {
		cons := fuzz.NewConsumer(bytes)

		parts := make([]interface{}, 0)
		err := cons.CreateSlice(&parts)
		if err != nil {
			return
		}

		_, err = funcs.GenerateJSON(parts...)
		if err != nil && !isExpectedErrorMessage(err.Error(), expectedErrors) {
			t.Errorf("Smth went wrong: %s", err)
		}
		// Additional checks can be added here if needed
	})
}

func isExpectedErrorMessage(message string, expectedMessages []string) bool {
	return slices.Contains(expectedMessages, message)
}
