package main

// Edit if desired. Code generated by "fzgen io".

import (
	"io"
	"testing"

	"github.com/thepudds/fzgen/fuzzer"
)

func Fuzz_LimitedReader_Read(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var l *io.LimitedReader
		var p []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&l, &p)
		if l == nil {
			return
		}

		l.Read(p)
	})
}

func Fuzz_OffsetWriter_Seek(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var o *io.OffsetWriter
		var offset int64
		var whence int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&o, &offset, &whence)
		if o == nil {
			return
		}

		o.Seek(offset, whence)
	})
}

func Fuzz_OffsetWriter_Write(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var o *io.OffsetWriter
		var p []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&o, &p)
		if o == nil {
			return
		}

		o.Write(p)
	})
}

func Fuzz_OffsetWriter_WriteAt(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var o *io.OffsetWriter
		var p []byte
		var off int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&o, &p, &off)
		if o == nil {
			return
		}

		o.WriteAt(p, off)
	})
}

func Fuzz_PipeReader_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *io.PipeReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.Close()
	})
}

// skipping Fuzz_PipeReader_CloseWithError because parameters include func, chan, or unsupported interface: error

func Fuzz_PipeReader_Read(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *io.PipeReader
		var d2 []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &d2)
		if r == nil {
			return
		}

		r.Read(d2)
	})
}

func Fuzz_PipeWriter_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *io.PipeWriter
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.Close()
	})
}

// skipping Fuzz_PipeWriter_CloseWithError because parameters include func, chan, or unsupported interface: error

func Fuzz_PipeWriter_Write(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *io.PipeWriter
		var d2 []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &d2)
		if w == nil {
			return
		}

		w.Write(d2)
	})
}

func Fuzz_SectionReader_Outer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.ReaderAt
		var off int64
		var n int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &off, &n)

		s := io.NewSectionReader(r, off, n)
		s.Outer()
	})
}

func Fuzz_SectionReader_Read(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.ReaderAt
		var off int64
		var n int64
		var p []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &off, &n, &p)

		s := io.NewSectionReader(r, off, n)
		s.Read(p)
	})
}

func Fuzz_SectionReader_ReadAt(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.ReaderAt
		var o2 int64
		var n int64
		var p []byte
		var o5 int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &o2, &n, &p, &o5)

		s := io.NewSectionReader(r, o2, n)
		s.ReadAt(p, o5)
	})
}

func Fuzz_SectionReader_Seek(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.ReaderAt
		var off int64
		var n int64
		var offset int64
		var whence int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &off, &n, &offset, &whence)

		s := io.NewSectionReader(r, off, n)
		s.Seek(offset, whence)
	})
}

func Fuzz_SectionReader_Size(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.ReaderAt
		var off int64
		var n int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &off, &n)

		s := io.NewSectionReader(r, off, n)
		s.Size()
	})
}

func Fuzz_Copy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dst io.Writer
		var src io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dst, &src)

		io.Copy(dst, src)
	})
}

func Fuzz_CopyBuffer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dst io.Writer
		var src io.Reader
		var buf []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dst, &src, &buf)

		io.CopyBuffer(dst, src, buf)
	})
}

func Fuzz_CopyN(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dst io.Writer
		var src io.Reader
		var n int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dst, &src, &n)

		io.CopyN(dst, src, n)
	})
}

func Fuzz_LimitReader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		var n int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &n)

		io.LimitReader(r, n)
	})
}

func Fuzz_MultiReader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var readers []io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&readers)

		io.MultiReader(readers...)
	})
}

func Fuzz_MultiWriter(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var writers []io.Writer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&writers)

		io.MultiWriter(writers...)
	})
}

// skipping Fuzz_NewOffsetWriter because parameters include func, chan, or unsupported interface: io.WriterAt

func Fuzz_NewSectionReader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.ReaderAt
		var off int64
		var n int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &off, &n)

		io.NewSectionReader(r, off, n)
	})
}

func Fuzz_NopCloser(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)

		io.NopCloser(r)
	})
}

func Fuzz_ReadAll(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)

		io.ReadAll(r)
	})
}

func Fuzz_ReadAtLeast(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		var buf []byte
		var min int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &buf, &min)

		io.ReadAtLeast(r, buf, min)
	})
}

func Fuzz_ReadFull(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		var buf []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &buf)

		io.ReadFull(r, buf)
	})
}

func Fuzz_TeeReader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r io.Reader
		var w io.Writer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &w)

		io.TeeReader(r, w)
	})
}

func Fuzz_WriteString(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w io.Writer
		var s string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &s)

		io.WriteString(w, s)
	})
}
