package main

// Edit if desired. Code generated by "fzgen -mocks --mocksPackagePrefix=example --mocksDepth=5 --llm=groq github.com/mholt/binding".
// false
// depth of context
// func

import (
	"context"
	mocks_2 "example/mocks/context"
	mocks_3 "example/mocks/github.com/mholt/binding"
	mocks_1 "example/mocks/io"
	mocks "example/mocks/net/http"
	"io"
	"net/http"
	"reflect"
	"strings"
	"testing"
	"time"

	"github.com/BelehovEgor/fzgen/fuzzer"
	binding "github.com/mholt/binding"
	"github.com/stretchr/testify/mock"
)

func Fuzz_N1_Errors_Add(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e *binding.Errors
		var fieldNames []string
		var classification string
		var message string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e, &fieldNames, &classification, &message)
		if err != nil || e == nil {
			return
		}

		e.Add(fieldNames, classification, message)
	})
}

func Fuzz_N2_Errors_Has(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e *binding.Errors
		var class string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e, &class)
		if err != nil || e == nil {
			return
		}

		e.Has(class)
	})
}

func Fuzz_N3_Errors_Len(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e *binding.Errors
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e)
		if err != nil || e == nil {
			return
		}

		e.Len()
	})
}

func Fuzz_N4_Error_Error(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e binding.Error
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e)
		if err != nil {
			return
		}

		e.Error()
	})
}

func Fuzz_N5_Error_Fields(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e binding.Error
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e)
		if err != nil {
			return
		}

		e.Fields()
	})
}

func Fuzz_N6_Error_Kind(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e binding.Error
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e)
		if err != nil {
			return
		}

		e.Kind()
	})
}

func Fuzz_N7_Errors_Error(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e binding.Errors
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e)
		if err != nil {
			return
		}

		e.Error()
	})
}

func Fuzz_N8_Errors_Handle(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e binding.Errors
		var response http.ResponseWriter
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&e, &response)
		if err != nil {
			return
		}

		e.Handle(response)
	})
}

func Fuzz_N9_Bind(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var req *http.Request
		var userStruct binding.FieldMapper
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&req, &userStruct)
		if err != nil || req == nil {
			return
		}

		if req.Header == nil {
			return
		}

		contentType := req.Header.Get("Content-Type")
		if contentType == "" && len(req.URL.Query()) == 0 {
			return
		}

		errs := binding.Bind(req, userStruct)
		if len(errs) > 0 {
			for _, err := range errs {
				if err.Error() == "Empty Content-Type" || err.Error() == "Unsupported Content-Type" {
					return
				}
				t.Error("Unexpected error during binding")
			}
		}
	})
}

func Fuzz_N10_Form(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var req *http.Request
		var userStruct binding.FieldMapper
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&req, &userStruct)
		if err != nil || req == nil || userStruct == nil {
			return
		}

		if req.Header == nil {
			req.Header = make(http.Header)
		}

		contentType := req.Header.Get("Content-Type")
		if contentType == "" && len(req.URL.Query()) == 0 {
			t.Skip("Empty Content-Type and no query data")
		}

		if contentType != "" && !strings.Contains(contentType, "form-urlencoded") && !strings.Contains(contentType, "multipart/form-data") && !strings.Contains(contentType, "json") {
			t.Skip("Unsupported Content-Type")
		}

		errs := binding.Bind(req, userStruct)
		if len(errs) > 0 {
			for _, err := range errs {
				if err.Message == "Empty Content-Type" {
					t.Skip("Empty Content-Type error")
				}
				if err.Message == "Unsupported Content-Type" {
					t.Skip("Unsupported Content-Type error")
				}
				t.Error("Unexpected error")
			}
		}
	})
}

func Fuzz_N11_Json(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var req *http.Request
		var userStruct binding.FieldMapper
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&req, &userStruct)
		if err != nil || req == nil || userStruct == nil {
			t.Log("Skipping invalid input data")
			return
		}

		if req.Header == nil {
			t.Log("Skipping request with nil header")
			return
		}

		if userStruct == nil {
			t.Log("Skipping nil userStruct")
			return
		}

		result := binding.Json(req, userStruct)
		if len(result) > 0 {
			for _, err := range result {
				if err.Message == "Empty Content-Type" || err.Message == "Unsupported Content-Type" {
					t.Log("Skipping explicit exception messages")
					continue
				}
				t.Error("Error in result:", err.Message)
			}
		}
	})
}

func Fuzz_Bind(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var req *http.Request
		var userStruct binding.FieldMapper
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&req, &userStruct)
		if err != nil || req == nil {
			return
		}

		if req.Header == nil {
			t.Log("Request header is nil")
			return
		}

		contentType := req.Header.Get("Content-Type")
		if contentType == "" && len(req.URL.Query()) == 0 {
			t.Log("Empty Content-Type and no query parameters")
			return
		}

		switch {
		case strings.Contains(contentType, "form-urlencoded"):
			if reflect.TypeOf(userStruct).Kind() != reflect.Ptr {
				t.Error("Invalid userStruct type for form-urlencoded")
				return
			}
		case strings.Contains(contentType, "multipart/form-data"):
			if reflect.TypeOf(userStruct).Kind() != reflect.Ptr {
				t.Error("Invalid userStruct type for multipart/form-data")
				return
			}
		case strings.Contains(contentType, "json"):
			if reflect.TypeOf(userStruct).Kind() != reflect.Ptr {
				t.Error("Invalid userStruct type for json")
				return
			}
		default:
			if len(req.URL.Query()) == 0 {
				t.Error("Unsupported Content-Type and no query parameters")
				return
			}
		}

		errs := binding.Bind(req, userStruct)
		if len(errs) > 0 {
			for _, e := range errs {
				if e.Message == "Explicit exception message" {
					t.Log("Skipping explicit exception")
					return
				}
				t.Error("Error(s) found after binding")
			}
		}
	})
}

func Fuzz_N13_Validate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var errs binding.Errors
		var req *http.Request
		var userStruct binding.FieldMapper
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&errs, &req, &userStruct)
		if err != nil || req == nil {
			return
		}

		if req.Header.Get("Content-Type") == "" && len(req.URL.Query()) == 0 {
			t.Skip()
		}

		if m := userStruct.FieldMap(req); m != nil {
			t.Skip()
		}

		defer func() {
			if r := recover(); r != nil {
				if err, ok := r.(string); ok && err == "Required" {
					t.Skip()
				} else {
					t.Error("panic occurred")
				}
			}
		}()

		result := binding.Validate(errs, req, userStruct)

		if result == nil {
			t.Error("unexpected nil result")
		}
	})
}
func fabric_mock_interface_6_FieldMapper(
	t *testing.T,
	fieldmap_ binding.FieldMap,
) binding.FieldMapper {
	genMock := mocks_3.NewMockFieldMapper(t)
	genMock.
		On("FieldMap", mock.AnythingOfType("*http.Request")).
		Return(func(*http.Request) binding.FieldMap {
			return fieldmap_
		}).
		Maybe()
	return genMock
}

func fabric_mock_interface_5_Context(
	t *testing.T,
	deadline time.Time,
	ok bool,
	error_ error,
) context.Context {
	genMock := mocks_2.NewMockContext(t)
	genMock.
		On("Deadline").
		Return(func() (deadline time.Time, ok bool) {
			return deadline, ok
		}).
		Maybe()
	genMock.
		On("Err").
		Return(func() error {
			return error_
		}).
		Maybe()
	return genMock
}

func fabric_mock_interface_2_ReadCloser(
	t *testing.T,
	error_ error,
	n int,
	err error,
) io.ReadCloser {
	genMock := mocks_1.NewMockReadCloser(t)
	genMock.
		On("Close").
		Return(func() error {
			return error_
		}).
		Maybe()
	genMock.
		On("Read", mock.AnythingOfType("[]byte")).
		Return(func(p []byte) (n int, err error) {
			return n, err
		}).
		Maybe()
	return genMock
}

func fabric_mock_interface_1_ResponseWriter(
	t *testing.T,
	header_ http.Header,
	int_ int,
	error_ error,
) http.ResponseWriter {
	genMock := mocks.NewMockResponseWriter(t)
	genMock.
		On("Header").
		Return(func() http.Header {
			return header_
		}).
		Maybe()
	genMock.
		On("Write", mock.AnythingOfType("[]byte")).
		Return(func([]byte) (int, error) {
			return int_, error_
		}).
		Maybe()
	genMock.
		On("WriteHeader", mock.AnythingOfType("int")).
		Return(func(statusCode int) {
			return
		}).
		Maybe()
	return genMock
}

func fabric_mock_func_4(
	_arr_byte_ []byte,
	error_ error,
) func(string, []byte, int) ([]byte, error) {
	return func(string, []byte, int) ([]byte, error) {
		return _arr_byte_, error_
	}
}

func fabric_mock_func_3(
	readcloser_ io.ReadCloser,
	error_ error,
) func() (io.ReadCloser, error) {
	return func() (io.ReadCloser, error) {
		return readcloser_, error_
	}
}

func fabric_interface_empty_string(impl string) interface{} {
	return impl
}

func fabric_interface_empty_Field(impl binding.Field) interface{} {
	return impl
}

func fabric_interface_empty_Error(impl binding.Error) interface{} {
	return impl
}

var FabricFuncsForCustomTypes map[string][]reflect.Value

func TestMain(m *testing.M) {
	FabricFuncsForCustomTypes = make(map[string][]reflect.Value)
	FabricFuncsForCustomTypes["io.ReadCloser"] = append(FabricFuncsForCustomTypes["io.ReadCloser"], reflect.ValueOf(fabric_mock_interface_2_ReadCloser))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_Field))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_Error))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_string))
	FabricFuncsForCustomTypes["func()(io.ReadCloser,error)"] = append(FabricFuncsForCustomTypes["func()(io.ReadCloser,error)"], reflect.ValueOf(fabric_mock_func_3))
	FabricFuncsForCustomTypes["func(string,[]byte,int)([]byte,error)"] = append(FabricFuncsForCustomTypes["func(string,[]byte,int)([]byte,error)"], reflect.ValueOf(fabric_mock_func_4))
	FabricFuncsForCustomTypes["context.Context"] = append(FabricFuncsForCustomTypes["context.Context"], reflect.ValueOf(fabric_mock_interface_5_Context))
	FabricFuncsForCustomTypes["binding.FieldMapper"] = append(FabricFuncsForCustomTypes["binding.FieldMapper"], reflect.ValueOf(fabric_mock_interface_6_FieldMapper))
	FabricFuncsForCustomTypes["http.ResponseWriter"] = append(FabricFuncsForCustomTypes["http.ResponseWriter"], reflect.ValueOf(fabric_mock_interface_1_ResponseWriter))
	m.Run()
}
