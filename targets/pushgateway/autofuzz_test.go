package main

// Edit if desired. Code generated by "fzgen -mocks --mocksPackagePrefix=example --mocksDepth=5 --llm=groq github.com/kataras/go-serializer".
// false
// logic
// package

import (
	mocks "example/mocks/github.com/kataras/go-serializer"
	"reflect"
	"testing"

	"github.com/BelehovEgor/fzgen/fuzzer"
	serializer "github.com/kataras/go-serializer"
	"github.com/stretchr/testify/mock"
)

func Fuzz_N1_Serializers_For(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s serializer.Serializers
		var key string
		var serializer_0 []serializer.Serializer
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&s, &key, &serializer_0)
		if err != nil {
			return
		}

		s.For(key, serializer_0...)
	})
}

func Fuzz_N2_Serializers_Len(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s serializer.Serializers
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&s)
		if err != nil {
			return
		}

		s.Len()
	})
}

func Fuzz_N3_Serializers_Serialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s serializer.Serializers
		var key string
		var obj interface{}
		var options []map[string]interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&s, &key, &obj, &options)
		if err != nil {
			return
		}

		s.Serialize(key, obj, options...)
	})
}

func Fuzz_N4_Serializers_SerializeToString(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s serializer.Serializers
		var key string
		var obj interface{}
		var options []map[string]interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&s, &key, &obj, &options)
		if err != nil {
			return
		}

		s.SerializeToString(key, obj, options...)
	})
}

func Fuzz_N5_For(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var key string
		var serializer_0 []serializer.Serializer
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&key, &serializer_0)
		if err != nil {
			return
		}

		if key == "" {
			t.Log("key is empty, skipping")
			return
		}

		for _, s := range serializer_0 {
			if s == nil {
				t.Log("nil serializer found, skipping")
				return
			}
		}

		defer func() {
			if r := recover(); r != nil {
				if r == "explicit exception message" {
					t.Log("explicit exception, skipping")
				} else {
					t.Error("unexpected panic")
				}
			}
		}()

		serializer.For(key, serializer_0...)
	})
}

func Fuzz_N7_RegisterDefaults(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var serializers serializer.Serializers
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&serializers)
		if err != nil {
			t.Log("Skipping due to fuzzer error")
			return
		}

		defer func() {
			if r := recover(); r != nil {
				switch r := r.(type) {
				case string:
					if r == "expected error message" {
						t.Log("Skipping due to expected error")
						return
					}
				case error:
					if r.Error() == "expected error message" {
						t.Log("Skipping due to expected error")
						return
					}
				}
				t.Error("Unexpected panic occurred")
			}
		}()
	})
}

func Fuzz_N8_Serialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var key string
		var obj interface{}
		var options []map[string]interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&key, &obj, &options)
		if err != nil {
			return
		}

		if key == "" {
			t.Skip("key is empty")
		}

		if obj == nil {
			t.Skip("obj is nil")
		}

		if reflect.TypeOf(obj).Kind() == reflect.Func {
			t.Skip("obj is a function")
		}

		if len(options) > 0 {
			for _, opt := range options {
				if opt == nil {
					t.Skip("options contains nil map")
				}
			}
		}

		result, err := serializer.Serialize(key, obj, options...)
		if err != nil {
			if err.Error() == "explicit exception message" {
				t.Skip("explicit exception creation")
			}
			t.Error("serialize returned an error")
		}
		if result == nil {
			t.Error("serialize returned nil bytes")
		}
	})
}

func Fuzz_N9_SerializeToString(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var key string
		var obj interface{}
		var options []map[string]interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&key, &obj, &options)
		if err != nil {
			t.Skip()
		}

		str, err := serializer.SerializeToString(key, obj, options...)
		if err != nil {
			if err.Error() == "expected explicit error message" {
				t.Skip()
			}
			return
		}

		if str == "" {
			t.Error("unexpected empty result")
		}
		if err != nil {
			t.Error("unexpected error")
		}
	})
}
func fabric_mock_interface_1_Serializer(
	t *testing.T,
	_arr_byte_ []byte,
	error_ error,
) serializer.Serializer {
	genMock := mocks.NewMockSerializer(t)
	genMock.
		On("Serialize", mock.AnythingOfType("interface{}"), mock.AnythingOfType("[]map[string]interface{}")).
		Return(func(interface{}, ...map[string]interface{}) ([]byte, error) {
			return _arr_byte_, error_
		}).
		Maybe()
	return genMock
}

func fabric_interface_empty_string(impl string) interface{} {
	return impl
}

var FabricFuncsForCustomTypes map[string][]reflect.Value

func TestMain(m *testing.M) {
	FabricFuncsForCustomTypes = make(map[string][]reflect.Value)
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_string))
	FabricFuncsForCustomTypes["serializer.Serializer"] = append(FabricFuncsForCustomTypes["serializer.Serializer"], reflect.ValueOf(fabric_mock_interface_1_Serializer))
	m.Run()
}
