package main


// Edit if desired. Code generated by "fzgen -mocks --mocksPackagePrefix=example --mocksDepth=5 --llm=groq github.com/kr/pretty".

import (
	"testing"
	mocks_1 "example/mocks/github.com/kr/pretty"
	pretty "github.com/kr/pretty"
	"github.com/BelehovEgor/fzgen/fuzzer"
	"reflect"
	"github.com/stretchr/testify/mock"
	mocks "example/mocks/io"
	"io"
	"fmt"
)


func Fuzz_N1_Diff(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var a interface{}
		var b interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&a, &b)
		if err != nil {
			t.Log("Skipping due to filler error")
			return
		}

		defer func() {
			if r := recover(); r != nil {
				if err, ok := r.(error); ok && (err.Error() == "explicit exception message" || err.Error() == "another explicit exception message") {
					t.Log("Explicit exception, skipping")
				} else {
					t.Error("Unexpected panic")
				}
			}
		}()

		result := Diff(a, b)

		if reflect.TypeOf(result).Kind() != reflect.Slice {
			t.Error("Invalid return type")
		}

		if len(result) < 0 {
			t.Error("Invalid result length")
		}

		for _, desc := range result {
			if desc == "" {
				t.Error("Empty description in result")
			}
		}
	})
}

func Fuzz_N2_Errorf(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var format string
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&format, &a)
		if err != nil {
			return
		}

		if len(format) == 0 || len(a) == 0 {
			t.Skip()
		}

		err = pretty.Errorf(format, a...)
		if err == nil {
			t.Error("Expected error, but got nil")
		}

		expectedError := fmt.Errorf(format, a...)
		if err.Error() != expectedError.Error() {
			t.Error("Error message mismatch")
		}

		if err.Error() == "explicit exception" {
			t.Skip()
		}

		if reflect.TypeOf(err).String() != "*errors.errorString" {
			t.Error("Unexpected error type")
		}

		if err.Error() == "" {
			t.Error("Empty error message")
		}
	})
}

func Fuzz_N3_Fdiff(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w io.Writer
		var a interface{}
		var b interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&w, &a, &b)
		if err != nil {
			return
		}

		if w == nil {
			t.Log("Writer is nil, skipping")
			return
		}

		if a == nil && b == nil {
			t.Log("Both operands are nil, skipping")
			return
		}

		if reflect.TypeOf(a) == reflect.TypeOf(mock.Mock{}) || reflect.TypeOf(b) == reflect.TypeOf(mock.Mock{}) {
			t.Log("Mock objects detected, skipping")
			return
		}

		if reflect.ValueOf(w).Kind() != reflect.Ptr || reflect.ValueOf(w).IsNil() {
			t.Log("Writer is not a valid pointer, skipping")
			return
		}

		defer func() {
			if r := recover(); r != nil {
				if err, ok := r.(error); ok && (err.Error() == "explicit exception message 1" || err.Error() == "explicit exception message 2") {
					t.Log("Explicit exception, skipping")
				} else {
					t.Error("Function panicked with unexpected error")
				}
			}
		}()

		pretty.Fdiff(w, a, b)
	})
}

func Fuzz_N4_Formatter(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var x interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&x)
		if err != nil {
			return
		}

		defer func() {
			if r := recover(); r != nil {
				if r != "explicit exception message" {
					t.Error("Unexpected panic")
				}
			}
		}()

		f := pretty.Formatter(x)
		if f == nil {
			t.Error("Formatter returned nil")
		}
	})
}

func Fuzz_N5_Fprintf(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w io.Writer
		var format string
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&w, &format, &a)
		if err != nil {
			t.Skip("Fuzz data caused error during filling")
		}

		if w == nil {
			t.Skip("io.Writer is nil")
		}

		if format == "" {
			t.Skip("Format string is empty")
		}

		n, err := pretty.Fprintf(w, format, a...)
		if err != nil {
			if err.Error() == "explicit exception message" {
				t.Skip("Explicit exception detected, skipping...")
			}
			t.Error("Error from Fprintf")
			return
		}

		if n < 0 {
			t.Error("Negative result from Fprintf")
		}
	})
}

func Fuzz_N6_Ldiff(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var l pretty.Logfer
		var a interface{}
		var b interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&l, &a, &b)
		if err != nil {
			return
		}

		mockL := &mocks_1.MockLogfer{}
		mockL.On("Logf", mock.Anything).Return()

		defer func() {
			if r := recover(); r != nil {
				t.Error("Unexpected panic")
			}
			mockL.AssertExpectations(t)
		}()

		pretty.Ldiff(mockL, a, b)

		if t.Failed() {
			t.Error("Expected no failure")
		}
	})
}

func Fuzz_N7_Log(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&a)
		if err != nil {
			return
		}

		// Validate arguments before calling Log
		for _, arg := range a {
			if arg == nil {
				t.Skip()
			}
			switch v := arg.(type) {
			case string:
				if v == "" {
					t.Skip()
				}
			case int:
				if v < 0 {
					t.Skip()
				}
			case float64:
				if v < 0 {
					t.Skip()
				}
			default:
				t.Skip()
			}
		}

		defer func() {
			if r := recover(); r != nil {
				errStr := fmt.Sprintf("%v", r)
				if errStr == "explicit error message" {
					t.Skip()
				}
				t.Error("Unexpected panic")
			}
		}()

		pretty.Log(a...)
	})
}

func Fuzz_N8_Logf(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var format string
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&format, &a)
		if err != nil {
			return
		}

		// Validate format string and arguments
		if len(format) == 0 {
			t.Skip("empty format string")
		}
		if reflect.TypeOf(a).Kind() != reflect.Slice {
			t.Skip("invalid arguments type")
		}

		// Check for invalid argument types that would cause Logf to panic
		for _, arg := range a {
			if arg == nil {
				t.Skip("nil argument")
			}
			if !isValidArgumentType(arg) {
				t.Skip("invalid argument type")
			}
		}

		// Mock log.Printf to catch errors
		mockLog := new(mocks.Logger)
		pretty.Logf = mockLog.Printf

		// Fake error message for skipping
		expectedErrorMessage := "expected error message"
		mockLog.On("Print", expectedErrorMessage).Return()

		defer func() {
			if r := recover(); r != nil {
				t.Error("Logf caused a panic")
			}
		}()

		pretty.Logf(format, a...)

		mockLog.AssertExpectations(t)
	})

}

func isValidArgumentType(arg interface{}) bool {
	switch arg.(type) {
	case string, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, complex64, complex128, bool, uintptr, error:
		return true
	default:
		return false
	}
}

func Fuzz_N9_Logln(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&a)
		if err != nil {
			return
		}

		for _, elem := range a {
			if reflect.TypeOf(elem).Kind() == reflect.Invalid {
				t.Skip("Invalid type encountered")
			}
		}

		mockLog := new(mocks.Logger)
		mockLog.On("Println", mock.Anything).Return()
		mockPretty := new(mocks_1.Pretty)
		mockPretty.On("Logln", mock.Anything).Return()

		defer func() {
			if r := recover(); r != nil {
				if r == "explicit exception message" {
					t.Skip("Explicit exception encountered")
				}
				t.Error("Unexpected panic")
			}
		}()

		mockPretty.Logln(a...)
		if mockLog.AssertExpectations(t) || mockPretty.AssertExpectations(t) {
			t.Error("Mock expectations not met")
		}
	})
}

func Fuzz_N10_Pdiff(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var p MockPrintfer
		var a interface{}
		var b interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&p, &a, &b)
		if err != nil {
			return
		}

		p.On("Printf", mock.Anything).Return(nil).Run(func(args mock.Arguments) {
			if len(args) == 0 {
				t.Error("Printf called with no arguments")
			}
		})

		defer func() {
			if r := recover(); r != nil {
				if str, ok := r.(string); ok && (str == "invalid argument" || str == "unexpected error") {
					return
				}
				t.Error("Unexpected panic during function execution")
			}
		}()

		pdiffErr := false
		p.On("Printf", mock.Anything).Return(nil).Run(func(args mock.Arguments) {
			if args.Get(0) == "" {
				t.Error("Printf called with empty string")
			}
			if len(args) != 1 {
				t.Error("Printf called with incorrect number of arguments")
			}
			pdiffErr = true
		})

		pretty.Pdiff(&p, a, b)

		if pdiffErr {
			t.Error("Pdiff called Printf with error description")
		}

		p.AssertExpectations(t)
	})
}

func Fuzz_N11_Print(f *testing.F) {
    f.Fuzz(func(t *testing.T, data []byte) {
        var a []interface{}
        fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
        err := fz.Fill2(&a)
        if err != nil {
            return
        }

        for _, arg := range a {
            if arg == nil {
                t.Skip("nil argument is invalid")
            }
            switch v := arg.(type) {
            case string:
                if v == "" {
                    t.Skip("empty string is invalid")
                }
            case int:
                if v < 0 {
                    t.Skip("negative int is invalid")
                }
            case float64:
                if v < 0 {
                    t.Skip("negative float64 is invalid")
                }
            case bool:
                // bool is always valid
            default:
                t.Log("unknown type, skipping")
                t.Skip()
            }
        }

        n, errno := pretty.Print(a...)
        if errno != nil {
            if errno.Error() == "explicit exception message" {
                t.Skip()
            }
            t.Error("unexpected error from pretty.Print")
        }
        if n < 0 {
            t.Error("negative number of bytes written")
        }
    })
}

func Fuzz_N12_Printf(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var format string
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&format, &a)
		if err != nil {
			return
		}

		if format == "" {
			t.Skip("format is empty")
		}

		if reflect.ValueOf(a).IsValid() && reflect.ValueOf(a).IsNil() {
			t.Skip("a is nil")
		}

		n, errno := Printf(format, a...)
		if errno != nil {
			if errno.Error() == "explicit exception message" {
				t.Skip("explicit exception")
			}
			t.Error("Printf returned error")
		}

		if n < 0 {
			t.Error("negative result from Printf")
		}
	})
}

func Fuzz_N13_Println(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&a)
		if err != nil {
			return
		}

		n, errno := Println(a...)
		if errno != nil {
			if errno.Error() == "explicit exception message" {
				return
			}
			t.Error("Println returned error")
		}
		if n < 0 {
			t.Error("Println returned negative output size")
		}
	})
}

func Fuzz_N14_Sprint(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&a)
		if err != nil {
			return
		}

		for _, arg := range a {
			val := reflect.ValueOf(arg)
			if !val.IsValid() || val.IsNil() {
				t.Skip()
			}
			if val.Kind() == reflect.Interface && val.NumMethod() == 0 {
				t.Skip()
			}
		}

		defer func() {
			if r := recover(); r != nil {
				if err, ok := r.(error); ok {
					if err.Error() == "explicit exception" {
						t.Skip()
					}
				}
				t.Error("unexpected panic")
			}
		}()

		result := pretty.Sprint(a...)
		if result == "" {
			t.Error("unexpected empty result")
		}
	})
}

func Fuzz_N15_Sprintf(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var format string
		var a []interface{}
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&format, &a)
		if err != nil {
			return
		}

		result := pretty.Sprintf(format, a...)
		if result == "" {
			t.Error("Result should not be empty")
		}
	})
}
func fabric_mock_interface_3_Printfer(
	t *testing.T,
) pretty.Printfer {
	genMock := mocks_1.NewMockPrintfer(t)
	genMock.
		On("Printf", mock.AnythingOfType("string"), mock.AnythingOfType("[]interface{}")).
		Return(func(format string, a ...interface{}) {
			return 
		}).
		Maybe()
	return genMock
}

func fabric_mock_interface_2_Logfer(
	t *testing.T,
) pretty.Logfer {
	genMock := mocks_1.NewMockLogfer(t)
	genMock.
		On("Logf", mock.AnythingOfType("string"), mock.AnythingOfType("[]interface{}")).
		Return(func(format string, a ...interface{}) {
			return 
		}).
		Maybe()
	return genMock
}

func fabric_mock_interface_1_Writer(
	t *testing.T,
	n int,
	err error,
) io.Writer {
	genMock := mocks.NewMockWriter(t)
	genMock.
		On("Write", mock.AnythingOfType("[]byte")).
		Return(func(p []byte) (n int, err error) {
			return n, err
		}).
		Maybe()
	return genMock
}

func fabric_interface_empty_string(impl string) interface{} {
	return impl
}

var FabricFuncsForCustomTypes map[string][]reflect.Value

func TestMain(m *testing.M) {
	FabricFuncsForCustomTypes = make(map[string][]reflect.Value)
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_string))
	FabricFuncsForCustomTypes["io.Writer"] = append(FabricFuncsForCustomTypes["io.Writer"], reflect.ValueOf(fabric_mock_interface_1_Writer))
	FabricFuncsForCustomTypes["pretty.Logfer"] = append(FabricFuncsForCustomTypes["pretty.Logfer"], reflect.ValueOf(fabric_mock_interface_2_Logfer))
	FabricFuncsForCustomTypes["pretty.Printfer"] = append(FabricFuncsForCustomTypes["pretty.Printfer"], reflect.ValueOf(fabric_mock_interface_3_Printfer))
	FabricFuncsForCustomTypes["fmt.Formatter"] = append(FabricFuncsForCustomTypes["fmt.Formatter"], reflect.ValueOf(pretty.Formatter))
	FabricFuncsForCustomTypes["error"] = append(FabricFuncsForCustomTypes["error"], reflect.ValueOf(pretty.Errorf))
	m.Run()
}

