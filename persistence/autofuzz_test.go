package main

// Edit if desired. Code generated by "fzgen github.com/zond/god/persistence".

import (
	"fmt"
	"reflect"
	"testing"
	"time"

	"github.com/BelehovEgor/fzgen/fuzzer"
	persistence "github.com/zond/god/persistence"
)

// Two different examples of usage
// Panic as possible response
// func return chan
func Fuzz_N5_Logger_Record_default(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var self *persistence.Logger
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&self)
		if err != nil || self == nil {
			return
		}

		// Put here your precondition of func arguments...

		self.Record()

		// Put here your postcondition of func results...
	})
}

// Prompt 1
/*
You write fuzzing test using golang

Purpose: extend target func result check in fuzzing target

Requirements:
        + return only fuzz target code
        + you can past code only instead comments like "Put here your"
        + no explanation
        + process all edge cases
        + if arguments is invalid, target function shouldn't be call, this case should be skipped
        + if there is an explicit exception creation, skip only them by their message, the rest should cause a fuzzing test error
        + situations that should not occur during the execution of the function should end with t.Error
        + use simple strings for t.Error or t.Log without any variables format
        + don't use not exported fields in validation checks (its starts with lowercase letter)

Target func from package github.com/zond/god/persistence:

func (self *Logger) Record() (rval chan *logfile) {
        if !self.changeState(stopped, recording) {
                panic(fmt.Errorf("%v unable to change state from stopped to recording", self))
        }
        rval = make(chan *logfile, 1)
        go self.record(rval)
        return
}

Example of using func:

func (self *Logger) snapshotAndDelete(oldrec *logfile, p chan *logfile, snapping *int32) {
        defer atomic.StoreInt32(snapping, 0)
        defer self.cond.Broadcast()
        latestSnapshot, logfiles := self.latest()
        snapshotter := NewLogger(self.dir).setSuffix(unfinishedSuffix)
        snapshotfile := <-snapshotter.Record()
        p <- snapshotfile
        snapshotter.snapshot(latestSnapshot, logfiles)
        snapshotter.Stop()
        if err := os.Rename(snapshotfile.filename, filepath.Join(self.dir, fmt.Sprintf("%v.%v", snapshotfile.timestamp.UnixNano(), snapSuffix))); err != nil {
                panic(err)
        }
        self.clearOlderThan(snapshotfile.timestamp)
}

Current fuzzing target test:

func Fuzz_N5_Logger_Record(f *testing.F) {
        f.Fuzz(func(t *testing.T, data []byte) {
                var self *persistence.Logger
                fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
                err := fz.Fill2(&self)
                if err != nil || self == nil {
                        return
                }

                // Put here your precondition of func arguments...

                self.Record()

                // Put here your postcondition of func results...
        })
}

Current import aliases:

import (
        "reflect"
        "testing"

        "github.com/BelehovEgor/fzgen/fuzzer"
        persistence "github.com/zond/god/persistence"
)
*/

// #LLM claude-3-7-sonnet-20250219
// count fixes: 0
// #summary:
// valid precondition.
// valid post condition.
// fuzzing 32

func Fuzz_N5_Logger_Record_claude_1(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var self *persistence.Logger
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&self)
		if err != nil || self == nil {
			return
		}

		// Catch panics and check for expected error messages
		defer func() {
			if r := recover(); r != nil {
				// If the panic contains the expected error about state change, that's expected
				if err, ok := r.(error); ok && err.Error() != "" {
					if reflect.TypeOf(r).String() == "*errors.errorString" {
						t.Error("Unexpected error type in panic")
					}
				} else {
					t.Error("Panic occurred with unexpected value")
				}
			}
		}()

		rval := self.Record()

		if rval == nil {
			t.Error("Record() returned nil channel")
		}

		// Check channel capacity
		chanType := reflect.TypeOf(rval)
		if chanType.Kind() != reflect.Chan {
			t.Error("Record() did not return a channel")
		}

		if cap(rval) != 1 {
			t.Error("Record() returned a channel with wrong capacity")
		}

		// Check channel element type
		if chanType.Elem().String() != "*github.com/zond/god/persistence.logfile" {
			t.Error("Record() returned a channel with wrong element type")
		}
	})
}

// #LLM claude-3-7-sonnet-20250219-thinking-32k
// count fixes: 0
// #summary:
// valid precondition.
// valid postcondition.
// fuzzing succ 20
func Fuzz_N5_Logger_Record_sonnet_thinking(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var self *persistence.Logger
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&self)
		if err != nil || self == nil {
			return
		}

		defer func() {
			r := recover()
			if r != nil {
				// Expected panic if state cannot be changed to recording
				// Skip the test in case of panic
				return
			}
		}()

		rval := self.Record()

		if rval == nil {
			t.Error("Returned channel is nil")
		}

		// Verify it's a buffered channel with capacity 1
		ch := reflect.ValueOf(rval)
		if ch.Cap() != 1 {
			t.Error("Channel capacity is not 1")
		}

		// Avoid goroutine leak
		select {
		case <-rval:
			// Successfully read from channel
		default:
			// Channel is empty, that's also fine
		}
	})
}

// #LLM chatgpt-4o-latest-20250129
// count fixes: 1
// using unexists
// #summary:
// valid precondition.
// valid post condition.

func Fuzz_N5_Logger_Record_gpt_1(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var self *persistence.Logger
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&self)
		if err != nil || self == nil {
			return
		}

		// if !self.ChangeState(stopped, recording) {
		// 	return
		// }

		defer func() {
			if r := recover(); r != nil {
				if err, ok := r.(error); ok {
					if err.Error() == fmt.Sprintf("%v unable to change state from stopped to recording", self) {
						return
					}
				}
				t.Error("Unexpected panic")
			}
		}()

		ch := self.Record()

		if ch == nil {
			t.Error("Returned channel is nil")
		}
	})
}

// Prompt 2
/*
You write fuzzing test using golang

Purpose: extend target func result check in fuzzing target

Requirements:
        + return only fuzz target code
        + you can past code only instead comments like "Put here your"
        + no explanation
        + process all edge cases
        + if arguments is invalid, target function shouldn't be call, this case should be skipped
        + if there is an explicit exception creation, skip only them by their message, the rest should cause a fuzzing test error
        + situations that should not occur during the execution of the function should end with t.Error
        + use simple strings for t.Error or t.Log without any variables format
        + don't use not exported fields in validation checks (its starts with lowercase letter)

Target func from package github.com/zond/god/persistence:

func (self *Logger) Record() (rval chan *logfile) {
        if !self.changeState(stopped, recording) {
                panic(fmt.Errorf("%v unable to change state from stopped to recording", self))
        }
        rval = make(chan *logfile, 1)
        go self.record(rval)
        return
}

Example of using func:

func (self *Logger) Clear() {
	self.Stop()
	self.clearOlderThan(time.Now())
	<-self.Record()
}

Current fuzzing target test:

func Fuzz_N5_Logger_Record(f *testing.F) {
        f.Fuzz(func(t *testing.T, data []byte) {
                var self *persistence.Logger
                fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
                err := fz.Fill2(&self)
                if err != nil || self == nil {
                        return
                }

                // Put here your precondition of func arguments...

                self.Record()

                // Put here your postcondition of func results...
        })
}

Current import aliases:

import (
        "reflect"
        "testing"

        "github.com/BelehovEgor/fzgen/fuzzer"
        persistence "github.com/zond/god/persistence"
)
*/

// #LLM claude-3-7-sonnet-20250219
// count fixes: 0
// #summary:
// valid precondition.
// valid post condition.
func Fuzz_N5_Logger_Record_claude_2(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var self *persistence.Logger
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&self)
		if err != nil || self == nil {
			return
		}

		// Skip if logger is not in stopped state
		if reflect.ValueOf(self).Elem().FieldByName("state").Int() != int64(0) {
			return
		}

		defer func() {
			r := recover()
			if r != nil {
				// Skip only the specific panic we expect
				if err, ok := r.(error); ok && err.Error() != fmt.Sprintf("%v unable to change state from stopped to recording", self) {
					t.Error("Unexpected panic in Record")
				}
			}
		}()

		result := self.Record()

		if result == nil {
			t.Error("Record returned nil channel")
			return
		}

		// Check if channel is buffered with size 1
		chanType := reflect.TypeOf(result)
		if chanType.ChanDir()&reflect.RecvDir == 0 {
			t.Error("Record returned a channel that cannot receive")
		}

		if reflect.ValueOf(result).Cap() != 1 {
			t.Error("Record returned channel with incorrect buffer size")
		}

		// Check if we can receive from the channel (should eventually produce a logfile)
		select {
		case logFile := <-result:
			if logFile == nil {
				t.Error("Received nil logfile from Record channel")
			}
		case <-time.After(100 * time.Millisecond):
			t.Log("Channel did not produce value within timeout")
		}
	})
}

// #LLM claude-3-7-sonnet-20250219-thinking-32k
// count fixes: 0
// #summary:
// valid precondition.
// valid postcondition.
// fuzzing succ 24
func Fuzz_N5_Logger_Record_claude_thinking(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var self *persistence.Logger
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&self)
		if err != nil || self == nil {
			return
		}

		defer func() {
			r := recover()
			if r != nil {
				// Expected panic, skip test
				return
			}
		}()

		rval := self.Record()

		if rval == nil {
			t.Error("Returned channel is nil")
		}

		// Verify it's a buffered channel with capacity 1
		ch := reflect.ValueOf(rval)
		if ch.Cap() != 1 {
			t.Error("Channel capacity is not 1")
		}

		// Avoid goroutine leak
		select {
		case <-rval:
			// Read from channel
		default:
			// Channel is empty
		}
	})
}

// #LLM chatgpt-4o-latest-20250129
// count fixes: 1
// invalid string creation
// #summary:
// valid precondition.
// valid post condition.

func Fuzz_N5_Logger_Record_gpt_2(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var self *persistence.Logger
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&self)
		if err != nil || self == nil {
			return
		}

		defer func() {
			if r := recover(); r != nil {
				if err, ok := r.(error); ok {
					// right way but incorrect syntax
					//if err.Error() == self.String()+" unable to change state from stopped to recording" {
					if err.Error() == fmt.Sprintf("%v unable to change state from stopped to recording", self) {
						return
					}
				}
				t.Error("unexpected panic")
			}
		}()

		if self == nil {
			return
		}

		// unexists
		// if !self.IsStopped() {
		// 	return
		// }

		ch := self.Record()

		if ch == nil {
			t.Error("returned channel is nil")
		}
	})
}

// Fabrics

func fabric_interface_empty_string(impl string) interface{} {
	return impl
}

func fabric_interface_empty_Op(impl persistence.Op) interface{} {
	return impl
}

func fabric_interface_empty_Logger(impl persistence.Logger) interface{} {
	return impl
}

func fabric_constructor_wrapper_NewLogger_0(
	dir string,
) (result persistence.Logger, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("runtime panic: %v", r)
		}
	}()

	res := persistence.NewLogger(
		dir,
	)
	return *res, err
}

var FabricFuncsForCustomTypes map[string][]reflect.Value

func TestMain(m *testing.M) {
	FabricFuncsForCustomTypes = make(map[string][]reflect.Value)
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_string))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_Op))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_Logger))
	FabricFuncsForCustomTypes["persistence.Logger"] = append(FabricFuncsForCustomTypes["persistence.Logger"], reflect.ValueOf(fabric_constructor_wrapper_NewLogger_0))
	m.Run()
}
