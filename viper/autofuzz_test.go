package main

// Edit if desired. Code generated by "fzgen github.com/spf13/viper".

import (
	"reflect"
	"strings"
	"testing"

	"github.com/BelehovEgor/fzgen/fuzzer"
	viper "github.com/spf13/viper"
)

// #1

// return nothing
// change reciver

// fuzz successful 124
func Fuzz_N4_Viper_AddConfigPath_default(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *viper.Viper
		var in string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&v, &in)
		if err != nil || v == nil {
			return
		}

		// Put here your precondition of func arguments...

		v.AddConfigPath(in)

		// Put here your postcondition of func results...
	})
}

// Prompt
/*
You write fuzzing test using golang

Purpose: extend target func result check in fuzzing target

Requirements:
        + return only fuzz target code
        + you can past code only instead comments like "Put here your"
        + no explanation
        + process all edge cases
        + if arguments is invalid, target function shouldn't be call, this case should be skipped
        + if there is an explicit exception creation, skip only them by their message, the rest should cause a fuzzing test error
        + situations that should not occur during the execution of the function should end with t.Error
        + use simple strings for t.Error or t.Log without any variables format
        + don't use not exported fields in validation checks (its starts with lowercase letter)

Target func from package github.com/spf13/viper:

func (v *Viper) AddConfigPath(in string) {
        if v.finder != nil {
                v.logger.Warn("ineffective call to function: custom finder takes precedence", slog.String("function", "AddConfigPath"))
        }

        if in != "" {
                absin := absPathify(v.logger, in)

                v.logger.Info("adding path to search paths", "path", absin)
                if !slices.Contains(v.configPaths, absin) {
                        v.configPaths = append(v.configPaths, absin)
                }
        }
}

Example of using func:

func AddConfigPath(in string) { v.AddConfigPath(in) }

Current fuzzing target test:

func Fuzz_N4_Viper_AddConfigPath(f *testing.F) {
        f.Fuzz(func(t *testing.T, data []byte) {
                var v *viper.Viper
                var in string
                fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
                err := fz.Fill2(&v, &in)
                if err != nil || v == nil {
                        return
                }

                // Put here your precondition of func arguments...

                v.AddConfigPath(in)

                // Put here your postcondition of func results...
        })
}

Current import aliases:

import (
        "io"
        "io/fs"
        "log/slog"
        "reflect"
        "strings"
        "testing"

        "github.com/BelehovEgor/fzgen/fuzzer"
        "github.com/spf13/pflag"
        viper "github.com/spf13/viper"
)
*/

// #LLM claude-3-7-sonnet-20250219
// count fixes: 1
// hallucinations
// #summary:
// invalid precondition.
// invalid postcondition.

func Fuzz_N4_Viper_AddConfigPath_claude(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *viper.Viper
		var in string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&v, &in)
		if err != nil || v == nil {
			return
		}

		// Store initial state for later comparison
		// initialConfigPathsLen := 0
		// if v.ConfigPaths != nil {
		// 	initialConfigPathsLen = len(v.ConfigPaths)
		// }

		// // Record if the path already exists
		// pathExists := false
		// if v.ConfigPaths != nil && in != "" {
		// 	absPath := absPathify(v.Logger, in)
		// 	for _, path := range v.ConfigPaths {
		// 		if path == absPath {
		// 			pathExists = true
		// 			break
		// 		}
		// 	}
		// }

		v.AddConfigPath(in)

		// Empty string should not be added
		// if in == "" {
		// 	if len(v.ConfigPaths) != initialConfigPathsLen {
		// 		t.Error("Empty string should not be added to config paths")
		// 	}
		// 	return
		// }

		// // If path already existed, length should not change
		// if pathExists {
		// 	if len(v.ConfigPaths) != initialConfigPathsLen {
		// 		t.Error("Path already existed but was added again")
		// 	}
		// 	return
		// }

		// // Path should be added if not empty and not already in the list
		// if len(v.ConfigPaths) != initialConfigPathsLen+1 {
		// 	t.Error("Path was not added correctly")
		// }

		// // Check if the last path is the absolutified version of input
		// absPath := absPathify(v.Logger, in)
		// if v.ConfigPaths[len(v.ConfigPaths)-1] != absPath {
		// 	t.Error("Added path is not correctly absolutified")
		// }
	})
}

// #LLM chatgpt-4o-latest-20250129
// count fixes: 1
// hallucinations
// #summary:
// invalid precondition.
// invalid postcondition.

func Fuzz_N4_Viper_AddConfigPath(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *viper.Viper
		var in string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&v, &in)
		if err != nil || v == nil {
			return
		}

		if strings.Contains(in, "\x00") {
			return
		}

		// initialPaths := make([]string, len(v.ConfigPaths()))
		// copy(initialPaths, v.ConfigPaths())

		v.AddConfigPath(in)

		// if in != "" {
		// 	absin := absPathify(v.Logger(), in)
		// 	if !slices.Contains(initialPaths, absin) && !slices.Contains(v.ConfigPaths(), absin) {
		// 		t.Error("path not added to config paths")
		// 	}
		// } else {
		// 	if len(v.ConfigPaths()) != len(initialPaths) {
		// 		t.Error("empty path should not modify config paths")
		// 	}
		// }
	})
}

// #2

// panic with specific error message
// fuzz fail - unhandled panic
func Fuzz_N45_Viper_MustBindEnv_default(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *viper.Viper
		var input []string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&v, &input)
		if err != nil || v == nil {
			return
		}

		// Put here your precondition of func arguments...

		v.MustBindEnv(input...)

		// Put here your postcondition of func results...
	})
}

// Prompt
/*
You write fuzzing test using golang

Purpose: extend target func result check in fuzzing target

Requirements:
        + return only fuzz target code
        + you can past code only instead comments like "Put here your"
        + no explanation
        + process all edge cases
        + if arguments is invalid, target function shouldn't be call, this case should be skipped
        + if there is an explicit exception creation, skip only them by their message, the rest should cause a fuzzing test error
        + situations that should not occur during the execution of the function should end with t.Error
        + use simple strings for t.Error or t.Log without any variables format
        + don't use not exported fields in validation checks (its starts with lowercase letter)

Target func from package github.com/spf13/viper:

func (v *Viper) MustBindEnv(input ...string) {
        if err := v.BindEnv(input...); err != nil {
                panic(fmt.Sprintf("error while binding environment variable: %v", err))
        }
}

Example of using func:

func MustBindEnv(input ...string) { v.MustBindEnv(input...) }

Current fuzzing target test:

func Fuzz_N45_Viper_MustBindEnv(f *testing.F) {
        f.Fuzz(func(t *testing.T, data []byte) {
                var v *viper.Viper
                var input []string
                fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
                err := fz.Fill2(&v, &input)
                if err != nil || v == nil {
                        return
                }

                // Put here your precondition of func arguments...

                v.MustBindEnv(input...)

                // Put here your postcondition of func results...
        })
}

Current import aliases:

import (
        "io"
        "io/fs"
        "log/slog"
        "reflect"
        "strings"
        "testing"

        "github.com/BelehovEgor/fzgen/fuzzer"
        "github.com/spf13/pflag"
        viper "github.com/spf13/viper"
)
*/

// #LLM claude-3-7-sonnet-20250219
// count fixes: 0
// #summary:
// valid precondition.
// valid post condition.
// fuzz successful 130

func Fuzz_N45_Viper_MustBindEnv_claude(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *viper.Viper
		var input []string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&v, &input)
		if err != nil || v == nil {
			return
		}

		// Check for empty input slice which would cause an error in BindEnv
		if len(input) == 0 {
			return
		}

		// Check for nil strings in input
		for _, s := range input {
			if s == "" {
				return
			}
		}

		// Use defer and recover to catch panics
		defer func() {
			if r := recover(); r != nil {
				errMsg, ok := r.(string)
				if !ok {
					t.Error("MustBindEnv panic with non-string value")
					return
				}

				// Only skip panics that explicitly mention "error while binding environment variable"
				if !strings.Contains(errMsg, "error while binding environment variable") {
					t.Error("MustBindEnv panic with unexpected message")
				}
			}
		}()

		v.MustBindEnv(input...)
	})
}

// #LLM chatgpt-4o-latest-20250129
// count fixes: 0
// #summary:
// valid precondition.
// invalid postcondition.
// fuzz fail

func Fuzz_N45_Viper_MustBindEnv_gpt(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *viper.Viper
		var input []string
		fz := fuzzer.NewFuzzerV2(data, FabricFuncsForCustomTypes, t, fuzzer.Constructors)
		err := fz.Fill2(&v, &input)
		if err != nil || v == nil {
			return
		}

		if len(input) == 0 {
			return
		}

		for _, s := range input {
			if s == "" {
				return
			}
		}

		defer func() {
			if r := recover(); r != nil {
				if msg, ok := r.(string); ok && strings.HasPrefix(msg, "error while binding environment variable:") {
					return
				}
				t.Error("unexpected panic")
			}
		}()

		v.MustBindEnv(input...)

		// this work wrong
		for _, s := range input {
			if !v.IsSet(s) {
				t.Error("environment variable not set")
			}
		}
	})
}

// Fabrics

func fabric_interface_viper_EncoderRegistry_DefaultCodecRegistry(impl *viper.DefaultCodecRegistry) viper.EncoderRegistry {
	return impl
}

func fabric_interface_viper_DecoderRegistry_DefaultCodecRegistry(impl *viper.DefaultCodecRegistry) viper.DecoderRegistry {
	return impl
}

func fabric_interface_viper_CodecRegistry_DefaultCodecRegistry(impl *viper.DefaultCodecRegistry) viper.CodecRegistry {
	return impl
}

func fabric_interface_empty_string(impl string) interface{} {
	return impl
}

func fabric_interface_empty_Viper(impl viper.Viper) interface{} {
	return impl
}

func fabric_interface_empty_RemoteResponse(impl viper.RemoteResponse) interface{} {
	return impl
}

func fabric_interface_empty_DefaultCodecRegistry(impl viper.DefaultCodecRegistry) interface{} {
	return impl
}

func fabric_interface_empty_ConfigParseError(impl viper.ConfigParseError) interface{} {
	return impl
}

func fabric_interface_empty_ConfigMarshalError(impl viper.ConfigMarshalError) interface{} {
	return impl
}

func fabric_interface_empty_ConfigFileNotFoundError(impl viper.ConfigFileNotFoundError) interface{} {
	return impl
}

func fabric_func_4(num byte) func() {
	switch num % 4 {
	case 0:
		return viper.WatchConfig
	case 1:
		return viper.Reset
	case 2:
		return viper.Debug
	case 3:
		return viper.AutomaticEnv
	default:
		panic("unreachable")
	}
}

func fabric_func_3(num byte) func() {
	switch num % 4 {
	case 0:
		return viper.WatchConfig
	case 1:
		return viper.Reset
	case 2:
		return viper.Debug
	case 3:
		return viper.AutomaticEnv
	default:
		panic("unreachable")
	}
}

func fabric_func_2(num byte) func() {
	switch num % 4 {
	case 0:
		return viper.WatchConfig
	case 1:
		return viper.Reset
	case 2:
		return viper.Debug
	case 3:
		return viper.AutomaticEnv
	default:
		panic("unreachable")
	}
}

func fabric_func_1(num byte) func() {
	switch num % 4 {
	case 0:
		return viper.WatchConfig
	case 1:
		return viper.Reset
	case 2:
		return viper.Debug
	case 3:
		return viper.AutomaticEnv
	default:
		panic("unreachable")
	}
}

var FabricFuncsForCustomTypes map[string][]reflect.Value

func TestMain(m *testing.M) {
	FabricFuncsForCustomTypes = make(map[string][]reflect.Value)
	FabricFuncsForCustomTypes["func()"] = append(FabricFuncsForCustomTypes["func()"], reflect.ValueOf(fabric_func_1))
	FabricFuncsForCustomTypes["func()"] = append(FabricFuncsForCustomTypes["func()"], reflect.ValueOf(fabric_func_2))
	FabricFuncsForCustomTypes["func()"] = append(FabricFuncsForCustomTypes["func()"], reflect.ValueOf(fabric_func_3))
	FabricFuncsForCustomTypes["func()"] = append(FabricFuncsForCustomTypes["func()"], reflect.ValueOf(fabric_func_4))
	FabricFuncsForCustomTypes["viper.CodecRegistry"] = append(FabricFuncsForCustomTypes["viper.CodecRegistry"], reflect.ValueOf(fabric_interface_viper_CodecRegistry_DefaultCodecRegistry))
	FabricFuncsForCustomTypes["viper.DecoderRegistry"] = append(FabricFuncsForCustomTypes["viper.DecoderRegistry"], reflect.ValueOf(fabric_interface_viper_DecoderRegistry_DefaultCodecRegistry))
	FabricFuncsForCustomTypes["viper.EncoderRegistry"] = append(FabricFuncsForCustomTypes["viper.EncoderRegistry"], reflect.ValueOf(fabric_interface_viper_EncoderRegistry_DefaultCodecRegistry))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_string))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_Viper))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_RemoteResponse))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_DefaultCodecRegistry))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_ConfigParseError))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_ConfigMarshalError))
	FabricFuncsForCustomTypes["interface {}"] = append(FabricFuncsForCustomTypes["interface {}"], reflect.ValueOf(fabric_interface_empty_ConfigFileNotFoundError))
	FabricFuncsForCustomTypes["viper.DefaultCodecRegistry"] = append(FabricFuncsForCustomTypes["viper.DefaultCodecRegistry"], reflect.ValueOf(viper.NewCodecRegistry))
	FabricFuncsForCustomTypes["viper.Viper"] = append(FabricFuncsForCustomTypes["viper.Viper"], reflect.ValueOf(viper.New))
	m.Run()
}
